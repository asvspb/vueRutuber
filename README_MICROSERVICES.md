# Архитектура микро-сервисов для Rutube проекта

## Обзор

В этом проекте реализована архитектура микро-сервисов для передачи данных фильмов на фронтенд. Архитектура состоит из следующих компонентов:

1. **Backend сервис** (FastAPI) - предоставляет API для работы с данными фильмов
2. **Frontend сервис** (Vue.js) - отображает данные фильмов на клиенте
3. **База данных** (SQLite) - хранит данные фильмов
4. **Кэш** (Redis) - обеспечивает быстрый доступ к часто запрашиваемым данным

## Структура проекта

```
backend/
├── app/
│   ├── models.py        # Модели данных (включая Movie)
│   ├── schemas.py       # Pydantic схемы (включая Movie)
│   ├── crud.py          # CRUD операции (включая Movie)
│   ├── main.py          # Основное приложение FastAPI с эндпоинтами для фильмов
│   ├── database.py      # Настройки базы данных
│   ├── rutube_scraper.py # Скрапер для получения данных с Rutube
│   └── seed_movies.py   # Скрипт для заполнения базы тестовыми данными
├── seed_db.py           # Скрипт для инициализации базы данных
```

```
src/
├── components/
│   └── MovieList.vue    # Компонент для отображения списка фильмов
├── composables/
│   └── useMovies.ts     # Композабл для работы с фильмами
├── services/
│   └── moviesService.ts # Сервис для API запросов к фильмам
```

## Модель данных фильма

Модель `Movie` включает следующие поля:
- `id` - уникальный идентификатор
- `title` - название фильма
- `year` - год выпуска
- `image_url` - URL изображения
- `thumbnail_url` - URL миниатюры
- `views` - количество просмотров
- `added_at` - дата добавления
- `source_url` - исходный URL
- `duration` - длительность
- `description` - описание
- `genre` - жанр
- `rating` - рейтинг
- `is_active` - статус активности

## API эндпоинты для фильмов

- `POST /movies/` - создать фильм
- `GET /movies/` - получить список фильмов
- `GET /movies/{id}` - получить фильм по ID
- `PUT /movies/{id}` - обновить фильм
- `DELETE /movies/{id}` - удалить фильм (логическое удаление)
- `GET /movies/year/{year}` - получить фильмы по году
- `GET /movies/genre/{genre}` - получить фильмы по жанру
- `POST /movies/{id}/increment-views` - увеличить количество просмотров

## Запуск приложения

### Запуск backend

1. Убедитесь, что установлены зависимости:
   ```bash
   cd backend
   pip install -r requirements.txt
   ```

2. Установите переменные окружения в файле `.env`:
   ```
   DATABASE_URL=sqlite+aiosqlite:///./data/db.sqlite
   SQLITE_PATH=/app/data/db.sqlite
   REDIS_HOST=redis
   REDIS_PORT=6379
   CORS_ORIGINS=http://localhost:4173,http://localhost:5173
   ```

3. Инициализируйте базу данных и заполните тестовыми данными:
   ```bash
   python seed_db.py
   ```

4. Запустите backend:
   ```bash
   uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
   ```

### Запуск frontend

1. Установите зависимости:
   ```bash
   npm install
   ```

2. Запустите frontend:
   ```bash
   npm run dev
   ```

## Скрапинг данных

Для получения данных с Rutube используется скрапер `rutube_scraper.py`, который:
- Собирает информацию о видео с Rutube
- Извлекает метаданные (название, URL, изображение, длительность, просмотры)
- Сохраняет данные в базу данных `rutube_videos.db`

Для импорта данных из `rutube_videos.db` в основную таблицу `movies` используется скрипт `import_rutube_data.py`, который:
- Извлекает видео из `rutube_videos.db`
- Преобразует данные в формат, подходящий для основной модели `Movie`
- Импортирует только уникальные видео (избегая дубликатов)
- Обрабатывает различные форматы дат и просмотров

## Фронтенд компоненты

### MovieList.vue
Компонент для отображения списка фильмов с:
- Пагинацией
- Отображением изображений
- Информацией о фильме (название, год, просмотры, жанр)
- Обработкой ошибок изображений

### useMovies.ts
Композабл, предоставляющий функции:
- `fetchMovies()` - получить список фильмов
- `fetchMovieById()` - получить фильм по ID
- `createMovie()` - создать фильм
- `updateMovie()` - обновить фильм
- `deleteMovie()` - удалить фильм
- `incrementMovieViews()` - увеличить просмотры

## Масштабируемость

Архитектура спроектирована с учетом масштабируемости:
- Каждый сервис может масштабироваться независимо
- Использование кэша Redis для ускорения доступа к данным
- Возможность добавления новых источников данных
- Поддержка фильтрации и поиска

## Дальнейшие улучшения

1. Добавить аутентификацию и авторизацию
2. Реализовать систему комментариев
3. Добавить систему рекомендаций
4. Интегрировать CDN для хранения медиафайлов
5. Добавить систему тегов и категорий
6. Реализовать систему оценок пользователей